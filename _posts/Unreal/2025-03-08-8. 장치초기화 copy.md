---
title: 8. ì¥ì¹˜ ì´ˆê¸°í™”
description: ì¸í”„ëŸ° Rookiss C++ê³¼ ì–¸ë¦¬ì–¼ë¡œ ë§Œë“œëŠ” MMORPG ê²Œì„ ê°œë°œ ì‹œë¦¬ì¦ˆ ê²Œì„ ìˆ˜í•™ê³¼ DirectX12ì„ ë“£ê³  ë¦¬ë·°í•œ ë‚´ìš©ì…ë‹ˆë‹¤.
author: songminseok
date: 2025-03-07 12:10:00 +09:00
categories:
  - ì¸í”„ëŸ° ê°•ì˜
  - Unreal MMORPG ê²Œì„ê°œë°œ | ê²Œì„ìˆ˜í•™ê³¼ DirectX12
tags:
  - ì¸í”„ëŸ°
  - ê°•ì˜
  - Unreal
  - c++
  - ê²Œì„ìˆ˜í•™
pin: true
math: true
mermaid: true
---

DirectX12 ì´ˆê¸°í™”ì— ëŒ€í•œ ë‚´ìš©ì„ ê°„ë‹¨í•˜ê²Œ ë¦¬ë·°í•˜ëŠ” ë‚´ìš©ì´ë‹¤.
ìì„¸í•œ ì½”ë“œë³´ë‹¤ ì–´ë–¤ íë¦„ìœ¼ë¡œ ë™ì‘í•˜ê³  ìˆìœ¼ë©°, ê° ê°œë…ë“¤ì´ ë¬´ì—‡ì„ ì˜ë¯¸í•˜ëŠ”ì§€ì— ëŒ€í•´ì„œ ì •ë¦¬í•˜ëŠ” ê²ƒì´ ëª©í‘œë‹¤.

DirectX12 ê°œë°œì„ ìœ„í•´ ê°œë°œ í¸ë¦¬í•œ ê¸°ëŠ¥ë“¤ì„ ì œê³µí•˜ê³  ìˆë‹¤. 

DirectX 12 ê°œë°œì„ ìœ„í•´ Microsoftì—ì„œ ì œê³µí•˜ëŠ” ë‹¤ì–‘í•œ ìƒ˜í”Œ ì½”ë“œ ë° ìœ í‹¸ë¦¬í‹°ê°€ ìˆë‹¤. ì•„ë˜ì™€ ê°™ì€ ì˜¤í”ˆì†ŒìŠ¤ë¥¼ ì°¸ê³ í•˜ë©´ ê°œë°œì„ ë”ìš± í¸ë¦¬í•˜ê²Œ ì§„í–‰í•  ìˆ˜ ìˆë‹¤.

[DirectX Graphics Samples](https://github.com/microsoft/DirectX-Graphics-Samples)   
[DirectXTex](https://github.com/microsoft/DirectXTex)

## êµ¬ì¡° ë¼ˆëŒ€
ğŸ“¦Client  
 â”£ ğŸ“œClient.cpp  
 â”£ ğŸ“œClient.h  
 â”£ ğŸ“œGame.cpp  
 â”£ ğŸ“œGame.h  
 â”£ ğŸ“œpch.cpp  
 â”£ ğŸ“œpch.h  
ğŸ“¦Engine  
 â”£ ğŸ“œCommandQueue.cpp  
 â”£ ğŸ“œCommandQueue.h  
 â”£ ğŸ“œd3dx12.h  
 â”£ ğŸ“œDescriptorHeap.cpp  
 â”£ ğŸ“œDescriptorHeap.h  
 â”£ ğŸ“œDevice.cpp  
 â”£ ğŸ“œDevice.h  
 â”£ ğŸ“œEngine.cpp  
 â”£ ğŸ“œEngine.h  
 â”£ ğŸ“œEngine.vcxproj  
 â”£ ğŸ“œEngine.vcxproj.filters  
 â”£ ğŸ“œEngine.vcxproj.user  
 â”£ ğŸ“œEnginePch.cpp  
 â”£ ğŸ“œEnginePch.h  
 â”£ ğŸ“œpch.cpp  
 â”£ ğŸ“œpch.h  
 â”£ ğŸ“œSwapChain.cpp  
 â”— ğŸ“œSwapChain.h
 
Clientì™€ Engineì„ ë¶„ë¦¬í•˜ì—¬ ì„¤ê³„í•˜ì˜€ìœ¼ë©°, Engineì—ì„œ ë¹Œë“œëœ íŒŒì¼ì„ í™œìš©í•˜ì—¬ Client í”„ë¡œê·¸ë¨ì´ ë™ì‘í•˜ë„ë¡ êµ¬ì„±ë˜ì–´ ìˆë‹¤.

## ê° íŒŒì¼ë³„ ê¸°ëŠ¥ ì„¤ëª…
### Client
Client.h, Client.cppíŒŒì¼ì—ì„œëŠ” Windowí”„ë¡œê·¸ë¨ì„ ë‹¤ë£¨ê³  ìˆë‹¤.
Windowí”„ë¡œê·¸ë¨ ì„¤ì •ê³¼ Main()í•¨ìˆ˜ì—ì„œ ìš°ë¦¬ê°€ ë§Œë“  Gameì„ ì‹¤í–‰ì‹œí‚¤ëŠ” ê¸°ëŠ¥ì„ í•˜ê³  ìˆë‹¤.

```c++
#include "pch.h"
#include "Game.h"
#include "Engine.h"

void Game::Init(const WindowInfo& info)
{
    GEngine->Init(info);
}

void Game::Update()
{
    GEngine->Render();
}
```
Game.h, Game.cppíŒŒì¼ì—ì„œëŠ” Engineì„ Init, Updateí•˜ëŠ” ë‚´ìš©ì´ë‹¤.
Engineì— ì´ë£¨ì§€ëŠ” ë‚´ìš©ë“¤ì´ ì•ìœ¼ë¡œ ë‹¤ë£¨ê²Œ ëœ ë‚´ìš©ì´ë‹ˆ, ì´ê³³ì— ì§‘ì¤‘í•˜ëŠ” ê²ƒì´ ì¢‹ì„ ê²ƒ ê°™ë‹¤.

Clientì—ì„œëŠ” ì „ë°˜ì ìœ¼ë¡œ ìœˆë„ìš° í”„ë¡œê·¸ë¨ì— Engineì„ ì˜¬ë ¤ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ê¸°ëŠ¥ì´ êµ¬í˜„ë˜ì–´ ìˆë‹¤.


### Engine
#### Engine í´ë˜ìŠ¤
##### Engine.cpp - Init

```c++
void Engine::Init(const WindowInfo& info)
{
    _window = info;
    ResizeWindow(info.width, info.height);

    _viewport = { 0, 0, static_cast<FLOAT>(info.width), static_cast<FLOAT>(info.height), 0.0f, 1.0f }; //
    _scissorRect = CD3DX12_RECT(0, 0, info.width, info.height); // CD3DX12_RECT - d3x12.hì— ì •ì˜ë˜ì–´ ìˆëŠ” êµ¬ì¡°ì²´

    _device = make_shared<Device>();
    _cmdQueue = make_shared<CommandQueue>();
    _swapChain = make_shared<SwapChain>();
    _descHeap = make_shared<DescriptorHeap>   
    _device->Init();
    _cmdQueue->Init(_device->GetDevice(), _swapChain, _descHeap);
    _swapChain->Init(info, _device->GetDXGI(), _cmdQueue->GetCmdQueue());
    _descHeap->Init(_device->GetDevice(), _swapChain);
}
```

{: .prompt-info }
> - `Device` : ê°ì¢… **ê°ì²´ë¥¼ ìƒì„±**í•˜ëŠ” ìš©ë„   
> - `CommandQueue` : ì¼ê°ì„ í•˜ë‚˜ì”© ì²˜ë¦¬í•˜ë©´ ë¹„íš¨ìœ¨ì ì´ê¸° ë•Œë¬¸ì—, **ì¼ê° ìŒ“ì•„ë‘ê³  í•œ ë²ˆì— ìš”ì²­**í•˜ë„ë¡ í•¨. ì»¤ë§¨ë” íŒ¨í„´ : íì— ìŒ“ì•„ë‘ê³  í•œ ë²ˆì— ì²˜ë¦¬í•˜ëŠ” ë°©ì‹   
> - `SwapChain` : ì „ë©´ ë²„í¼ì™€ í›„ë©´ ë²„í¼ë¥¼ êµí™˜í•˜ê¸° ìœ„í•œ ì—­í• ì„ ë‹´ë‹¹í•œë‹¤. ì „ë©´ ë²„í¼ëŠ” í™”ë©´ì— ë³´ì´ëŠ” ì¥ë©´, í›„ë©´ ë²„í¼ëŠ” ë‹¤ìŒ ì¥ë©´ì´ë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤. **ì „ë©´ ë²„í¼ì™€ í›„ë©´ ë²„í¼ë¥¼ ë°”ê¿”ê°€ë©´ì„œ í™”ë©´ì— ì¶œë ¥**ëœë‹¤.   
> - `DescrptorHeap` : ì¼ì¢…ì˜ ê¸°ì•ˆì„œë¡œ ì¼ê°ì„ ë§¡ê¸¸ ë•Œ í•´ë‹¹ **ì¼ê°ì— ëŒ€í•œ ì •ë³´**ë¥¼ ê°™ì´ ë„˜ê²¨ì£¼ê²Œ ëœë‹¤.   

##### Engine.cpp - Render, RenderBegin, RenderEnd
```c++
void Engine::Render()
{
	RenderBegin();
	// TODO: ì—¬ê¸°ì— ë Œë”ë§ ì½”ë“œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
	RenderEnd();
}

void Engine::RenderBegin()
{
	_cmdQueue->RenderBegin(&_viewport, &_scissorRect);
}

void Engine::RenderEnd()
{
	_cmdQueue->RenderEnd(&_viewport, &_scissorRect);
}
```

Renderí•¨ìˆ˜ëŠ” ë§¤ í”„ë ˆì„ ê·¸ë ¤ì§€ë©´ì„œ, RenderBeginê³¼ RenderEndì‚¬ì´ì— ì—¬ëŸ¬ ë¬¼ì²´ë¥¼ ê·¸ë¦¬ê²Œ ëœë‹¤.   

#### Device í´ë˜ìŠ¤
##### Device.h
```c++
#pragma once

// ì¸ë ¥ ì‚¬ë¬´ì†Œ : ê°ì¢… ê°ì²´ ìƒì„±ì„ í•˜ëŠ” ì—­í• 
class Device
{
public:
	void Init();

	ComPtr<IDXGIFactory> GetDXGI() { return _dxgi; }
	ComPtr<ID3D12Device> GetDevice() { return _device; }
private:
	// COM(Component Object Model) : 
	// - DXì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ë…ë¦½ì„±ê³¼ í•˜ìœ„ í˜¸í™©ì„±ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê¸°ìˆ 
	// - COM ê°ì²´(COM ì¸í¼í˜ì´ìŠ¤)ë¥¼ ì‚¬ìš©. ì„¸ë¶€ì‚¬í•­ì€ ìš°ë¦¬í•œí…Œ ìˆ¨ê²¨ì§
	// - ComPtr : ì¼ì¢…ì˜ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°
	// Comptr : ê·¸ë˜í”½ ì¹´ë“œë‘ í†µì‹ í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ê°ì²´.
	ComPtr<ID3D12Debug> _debugController;
	ComPtr<IDXGIFactory> _dxgi;		// í™”ë©´ ê´€ë ¨ ê¸°ëŠ¥ë“¤.
	ComPtr<ID3D12Device> _device;	// ê°ì¢… ê°ì²´ ìƒì„±.
};
```

{: .prompt-info }
> - CPU (ì¤‘ì•™ì²˜ë¦¬ì¥ì¹˜, Central Processing Unit)
> 	- ê³ ê¸‰ ì—°ì‚° ì²˜ë¦¬, ë…¼ë¦¬ ì—°ì‚° ë° ì œì–´
> - GPU (ê·¸ë˜í”½ì²˜ë¦¬ì¥ì¹˜, Graphics Processing Unit)
> 	- **ëŒ€ëŸ‰ì˜ ë‹¨ìˆœ ì—°ì‚°ì„ ë³‘ë ¬ë¡œ ì²˜ë¦¬í•˜ëŠ” ë° íŠ¹í™”**
> 	- **CPUëŠ” ì—¬ëŸ¬ ê°€ì§€ ì‘ì—…ì„ ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³ , GPUëŠ” ë§ì€ ë‹¨ìˆœ ì—°ì‚°ì„ ë™ì‹œì— ì²˜ë¦¬í•˜ëŠ” ë° ìµœì í™”ë¨**
> - GPUì™€ CPUì˜ í†µì‹  ë¬¸ì œ
> 	- **CPUì™€ GPUëŠ” ì§ì ‘ ì—°ê²°ë˜ì§€ ì•Šê³ , íŠ¹ì • APIë¥¼ í†µí•´ í†µì‹ í•´ì•¼ í•¨**
> 	- **GPU ì œì¡°ì‚¬(NVIDIA, AMD, Intel)ë§ˆë‹¤ ì•„í‚¤í…ì²˜(ì„¤ê³„ ë°©ì‹)ê°€ ë‹¤ë¦„**
> 	- **ë”°ë¼ì„œ ê²Œì„ì„ ë§Œë“¤ ë•Œ GPUì— ë§ì¶° ê°œë³„ì ìœ¼ë¡œ ê°œë°œí•˜ë©´ ë¹„íš¨ìœ¨ì ì„**
> 
> **ì¦‰, DirectXë¥¼ ì‚¬ìš©í•˜ë©´ ê°œë°œìê°€ íŠ¹ì • GPU ì œì¡°ì‚¬ì— ì˜ì¡´í•˜ì§€ ì•Šê³  ê·¸ë˜í”½ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŒ.**
> OpenGL, Vulkan ë“±ì´ ìˆìŒ.


##### Device.cpp - Init
```c++
#include "pch.h"
#include "Device.h"

void Device::Init()
{
#ifdef _DEBUG
	::D3D12GetDebugInterface(IID_PPV_ARGS(&_debugController));
	_debugController->EnableDebugLayer();
#endif

	::CreateDXGIFactory(IID_PPV_ARGS(&_dxgi));
	::D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&_device));
}

```

| í•¨ìˆ˜                | ì—­í•                       | ì£¼ìš” ê¸°ëŠ¥                                |
| ------------------- | ------------------------- | ---------------------------------------- |
| `CreateDXGIFactory` | DXGI íŒ©í† ë¦¬ ìƒì„±          | ì–´ëŒ‘í„°(ê·¸ë˜í”½ ì¹´ë“œ) ì—´ê±°, ìŠ¤ì™‘ ì²´ì¸ ìƒì„± |
| `D3D12CreateDevice` | Direct3D 12 ë””ë°”ì´ìŠ¤ ìƒì„± | GPU ì œì–´, ê·¸ë˜í”½ ë¦¬ì†ŒìŠ¤ ìƒì„± ë° ë Œë”ë§   |
| `_debugController`  |                           | ë””ë²„ê·¸ ë©”ì„¸ì§€ë¥¼ ë„ì›Œì£¼ëŠ” ê¸°ëŠ¥.           |


#### SwapChain í´ë˜ìŠ¤
##### SwapChain.h
```c++
#pragma once

class SwapChain
{
public:
	void Init(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue);

	void Present();
	void SwapIndex();

	ComPtr<IDXGISwapChain> GetSwapChain() { return _swapChain; }
	ComPtr<ID3D12Resource> GetRenderTarget(int32 index) { return _renderTargets[index]; }

	uint32 GetCurrentBackBufferIndex() { return _backBufferIndex; }
	ComPtr<ID3D12Resource> GetCurrentBackBufferResource() { return _renderTargets[_backBufferIndex]; }

private:
	ComPtr<IDXGISwapChain>	 _swapChain;
	ComPtr<ID3D12Resource>	 _renderTargets[SWAP_CHAIN_BUFFER_COUNT];
	uint32					 _backBufferIndex = 0;  // 0 - 1 ë°”ë€Œë©´ì„œ ì™”ë‹¤ê°”ë‹¤ í•¨.	
};


```

ê²Œì„ì—ì„œ ë§¤ í”„ë ˆì„ë§ˆë‹¤ ìƒˆë¡œìš´ í™”ë©´ì„ ê·¸ë ¤ì•¼ í•˜ë¯€ë¡œ, **ë Œë”ë§ëœ ê²°ê³¼ë¥¼ ì €ì¥í•˜ê³  í‘œì‹œí•˜ëŠ” ë²„í¼(Buffer)**ê°€ í•„ìš”í•˜ë‹¤.
ë§Œì•½ **ë‹¨ í•˜ë‚˜ì˜ ë²„í¼**ë§Œ ì‚¬ìš©í•˜ë©´, ìƒˆë¡œìš´ í”„ë ˆì„ì„ ê·¸ë¦¬ëŠ” ë„ì¤‘ ê¸°ì¡´ í™”ë©´ì´ ë®ì–´ì”Œì›Œì ¸ **í™”ë©´ì´ ê¹œë¹¡ì´ê±°ë‚˜ ê¹¨ì§€ëŠ” í˜„ìƒ(Flickering, Tearing)ì´ ë°œìƒ**í•  ìˆ˜ ìˆë‹¤.
ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **ë”ë¸” ë²„í¼ë§(Double Buffering)** ë° **SwapChain**ì´ ì‚¬ìš©ëœë‹¤.

{: .prompt-info }
> - **ë”ë¸” ë²„í¼ë§ì´ë€?**
> 	- ë‘ ê°œì˜ ë²„í¼ë¥¼ ë²ˆê°ˆì•„ ê°€ë©° ì‚¬ìš©í•˜ì—¬ í™”ë©´ì„ ë¶€ë“œëŸ½ê²Œ ì¶œë ¥í•˜ëŠ” ë°©ì‹
> 	- í•˜ë‚˜ì˜ ë²„í¼(Front Buffer)ëŠ” í˜„ì¬ í™”ë©´ì— í‘œì‹œë˜ê³ , ë‹¤ë¥¸ ë²„í¼(Back Buffer)ëŠ” ë‹¤ìŒ í”„ë ˆì„ì„ ì¤€ë¹„
> 	- ë°± ë²„í¼ê°€ ì™„ì„±ë˜ë©´ ë‘ ë²„í¼ë¥¼ **êµì²´(Swap)**í•˜ì—¬ ëŠê¹€ ì—†ì´ í™”ë©´ì„ ê°±ì‹ 
> 
> - **SwapChainì´ë€?**
> 	- DirectXì—ì„œ **ë”ë¸” ë²„í¼ë§ ë˜ëŠ” íŠ¸ë¦¬í”Œ ë²„í¼ë§ì„ êµ¬í˜„í•˜ëŠ” ê°ì²´**
> 	- **GPUì—ì„œ ë Œë”ë§í•œ í”„ë ˆì„ì„ í™”ë©´ì— ì¶œë ¥í•˜ëŠ” ì—­í• **
> 	- ì—¬ëŸ¬ ê°œì˜ ë²„í¼ë¥¼ ê´€ë¦¬í•˜ë©°, í™”ë©´ì„ ë¶€ë“œëŸ½ê²Œ ê°±ì‹ í•˜ë„ë¡ ë•ëŠ” **ë²„í¼ êµí™˜ ì‹œìŠ¤í…œ**

##### SwapChain.cpp
```c++
#include "pch.h"
#include "SwapChain.h"

void SwapChain::Init(const WindowInfo& info, ComPtr<IDXGIFactory> dxgi, ComPtr<ID3D12CommandQueue> cmdQueue)
{
	// ì´ì „ì— ë§Œë“  ì •ë³´ ë‚ ë¦°ë‹¤
	_swapChain.Reset();

	DXGI_SWAP_CHAIN_DESC sd;
	sd.BufferDesc.Width = static_cast<uint32>(info.width); // ë²„í¼ì˜ í•´ìƒë„ ë„ˆë¹„
	sd.BufferDesc.Height = static_cast<uint32>(info.height); // ë²„í¼ì˜ í•´ìƒë„ ë†’ì´
	sd.BufferDesc.RefreshRate.Numerator = 60; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
	sd.BufferDesc.RefreshRate.Denominator = 1; // í™”ë©´ ê°±ì‹  ë¹„ìœ¨
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // ë²„í¼ì˜ ë””ìŠ¤í”Œë ˆì´ í˜•ì‹
	sd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	sd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;
	sd.SampleDesc.Count = 1; // ë©€í‹° ìƒ˜í”Œë§ OFF
	sd.SampleDesc.Quality = 0;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // í›„ë©´ ë²„í¼ì— ë Œë”ë§í•  ê²ƒ 
	sd.BufferCount = SWAP_CHAIN_BUFFER_COUNT; // ì „ë©´+í›„ë©´ ë²„í¼
	sd.OutputWindow = info.hwnd;
	sd.Windowed = info.windowed;
	sd.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD; // ì „ë©´ í›„ë©´ ë²„í¼ êµì²´ ì‹œ ì´ì „ í”„ë ˆì„ ì •ë³´ ë²„ë¦¼
	sd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;

	// IDXGIFactoryì—ì„œ SwapChainì„ ìƒì„±í•˜ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŒ.
	dxgi->CreateSwapChain(cmdQueue.Get(), &sd, &_swapChain);

	for (int32 i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
		_swapChain->GetBuffer(i, IID_PPV_ARGS(&_renderTargets[i])); // swapchainì„ ì´ìš©í•´ _renderTargetsì„ ì €ì¥.
}
void SwapChain::Present()
{
	// Present the frame.	í™”ë©´ ê·¸ë¦¼.
	_swapChain->Present(0, 0);
}

void SwapChain::SwapIndex()	// 0 - 1 ë°”ë€Œë©´ì„œ ì™”ë‹¤ê°”ë‹¤ í•¨.
{
	_backBufferIndex = (_backBufferIndex + 1) % SWAP_CHAIN_BUFFER_COUNT;
}
```
#### DescriptorHeap í´ë˜ìŠ¤
##### DescriptorHeap.cpp
```c++
#include "pch.h"
#include "DescriptorHeap.h"
#include "SwapChain.h"

void DescriptorHeap::Init(ComPtr<ID3D12Device> device, shared_ptr<SwapChain> swapChain)
{
	_swapChain = swapChain;
	
	_rtvHeapSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	D3D12_DESCRIPTOR_HEAP_DESC rtvDesc;
	rtvDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvDesc.NumDescriptors = SWAP_CHAIN_BUFFER_COUNT;
	rtvDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	rtvDesc.NodeMask = 0;

	// ê°™ì€ ì¢…ë¥˜ì˜ ë°ì´í„°ë¼ë¦¬ ë°°ì—´ë¡œ ê´€ë¦¬
	// RTV ëª©ë¡ : [ ] [ ] - rendertarget
	// _rtvHeap ë°°ì—´
	device->CreateDescriptorHeap(&rtvDesc, IID_PPV_ARGS(&_rtvHeap));

	// D3D12_CPU_DESCRIPTOR_HANDLE
	// - CPUì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•œ ë””ìŠ¤í¬ë¦½í„° í™ì˜ ì‹œì‘ ì£¼ì†Œë¥¼ ë‚˜íƒ€ë‚´ëŠ” êµ¬ì¡°ì²´

	// ì‹œì‘ ì£¼ì†Œê°’ ë°°ì—´ì„ ì²«ë²ˆì§¸ ìš”ì†Œë¥¼ ë°›ìŒ.
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHeapBegin = _rtvHeap->GetCPUDescriptorHandleForHeapStart();
	
	for (int i = 0; i < SWAP_CHAIN_BUFFER_COUNT; i++)
	{
		_rtvHandle[i] = CD3DX12_CPU_DESCRIPTOR_HANDLE(rtvHeapBegin, i * _rtvHeapSize);
		device->CreateRenderTargetView(swapChain->GetRenderTarget(i).Get(), nullptr, _rtvHandle[i]);
	}
}

D3D12_CPU_DESCRIPTOR_HANDLE DescriptorHeap::GetBackBufferView()
{
	return GetRTV(_swapChain->GetCurrentBackBufferIndex());
}
```

DirectX 12ì—ì„œ `ID3D12Resource`ëŠ” **GPUê°€ ì‚¬ìš©í•  ë°ì´í„°(ë²„í¼, í…ìŠ¤ì²˜ ë“±)ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ê°ì²´**ì´ë‹¤.
í•˜ì§€ë§Œ, GPUëŠ” ì´ ë¦¬ì†ŒìŠ¤ê°€ **ì–´ë–¤ ìš©ë„ë¡œ ì‚¬ìš©ë˜ëŠ”ì§€** ì •í™•íˆ ì•Œì•„ì•¼ í•œë‹¤.

ğŸ“Œ **DirectX 11 vs DirectX 12ì˜ ì°¨ì´ì **

| DirectX 11                                                      | DirectX 12                                      |
| --------------------------------------------------------------- | ----------------------------------------------- |
| `View` ê°œë… ì‚¬ìš©                                                | `Descriptor Heap` ê°œë… ì‚¬ìš©                     |
| ê°œë³„ ê°ì²´ë§ˆë‹¤ View ìƒì„±                                         | `CreateDescriptorHeap`ì„ í†µí•´ ê´€ë¦¬              |
| `RenderTargetView (RTV)`, `DepthStencilView (DSV)` ë“± ê°œë³„ ìƒì„± | í•˜ë‚˜ì˜ í™ì—ì„œ RTV, DSV, CBV, SRV, UAV ë“±ì„ ê´€ë¦¬ |

ğŸ“Œ **ëŒ€í‘œì ì¸ Descriptorì˜ ì¢…ë¥˜**

| Descriptor Type                 | ì„¤ëª…                                            |
| ------------------------------- | ----------------------------------------------- |
| **Render Target View (RTV)**    | í”„ë ˆì„ ë²„í¼ì— ì¶œë ¥í•  ë•Œ ì‚¬ìš©                    |
| **Depth Stencil View (DSV)**    | ê¹Šì´(Depth) ë° ìŠ¤í…ì‹¤(Stencil) ì •ë³´ ì €ì¥        |
| **Constant Buffer View (CBV)**  | ì‰ì´ë”ì—ì„œ ìƒìˆ˜ ë²„í¼ë¥¼ ì‚¬ìš©í•  ë•Œ ì‚¬ìš©           |
| **Shader Resource View (SRV)**  | ì‰ì´ë”ì—ì„œ í…ìŠ¤ì²˜ ë° ê¸°íƒ€ ë°ì´í„°ë¥¼ ì½ì„ ë•Œ ì‚¬ìš© |
| **Unordered Access View (UAV)** | ì½ê¸°/ì“°ê¸° ê°€ëŠ¥ ë¦¬ì†ŒìŠ¤ (ì˜ˆ: ì»´í“¨íŠ¸ ì‰ì´ë”)       |

ğŸ“Œ **Descriptor Heapì˜ ì—­í• **  
âœ… ì—¬ëŸ¬ ê°œì˜ Descriptor(ì„œìˆ ì)ì„ í•œ ë²ˆì— ì €ì¥í•˜ê³  ê´€ë¦¬  
âœ… CPUê°€ GPUì—ê²Œ ë¦¬ì†ŒìŠ¤ ì •ë³´ë¥¼ ì „ë‹¬í•˜ëŠ” "ê¸°ì•ˆì„œ" ì—­í•   
âœ… `CreateDescriptorHeap`ì„ ì‚¬ìš©í•˜ì—¬ ìƒì„±

#### CommandQueue í´ë˜ìŠ¤
##### CommandQueue.h
```c++
#pragma once
class SwapChain;
class DescriptorHeap;

class CommandQueue
{
public:
	~CommandQueue();

	void Init(ComPtr<ID3D12Device> device, shared_ptr<SwapChain> swapChain, shared_ptr<DescriptorHeap> descHeap);
	void WaitSync();

	void RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect);
	void RenderEnd(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect);

	ComPtr<ID3D12CommandQueue> GetCmdQueue() { return _cmdQueue; }

private:
	ComPtr<ID3D12CommandQueue> 		_cmdQueue;
	ComPtr<ID3D12CommandAllocator> 		_cmdAlloc;
	ComPtr<ID3D12GraphicsCommandList> 	_cmdList;

	ComPtr<ID3D12Fence>			_fence;
	uint32					_fenceValue = 0;
	HANDLE					_fenceEvent = INVALID_HANDLE_VALUE;

	shared_ptr<SwapChain>			_swapChain;
	shared_ptr<DescriptorHeap>		_descHeap;

};
```
- **CPU â†” GPU ë™ì‹œ ì‘ì—…**
    - CPUëŠ” GPUì—ê²Œ ì‘ì—…(ëª…ë ¹)ì„ ìš”ì²­í•˜ê³ , GPUëŠ” ì´ë¥¼ ì²˜ë¦¬í•˜ì—¬ í™”ë©´ì„ ë Œë”ë§í•œë‹¤.
    - CPUê°€ ì™¸ì£¼ë¥¼ ì£¼ëŠ” ë™ì•ˆì—ë„ ê³„ì† ì‘ì—…ì„ ì§„í–‰ ê°€ëŠ¥í•˜ë‹¤.
- **í•˜ë‚˜ì”© ìš”ì²­í•˜ë©´ ë¹„íš¨ìœ¨ì ** â†’ ì—¬ëŸ¬ ê°œì˜ ëª…ë ¹ì„ ëª¨ì•„ í•œ ë²ˆì— ì „ë‹¬í•˜ëŠ” ê²ƒì´ ë” íš¨ìœ¨ì ì´ë‹¤.
- **CPUê°€ ëª…ë ¹ì„ ëª¨ì•„ì„œ ë³´ë‚´ê³ , GPUê°€ í•˜ë‚˜ì”© ì²˜ë¦¬í•˜ëŠ” ë°©ì‹**ìœ¼ë¡œ ì„±ëŠ¥ ìµœì í™” ê°€ëŠ¥í•˜ë‹¤.

| ê°ì²´                        | ì—­í•                     | ë¹„ìœ                                     |
| --------------------------- | ----------------------- | --------------------------------------- |
| `ID3D12GraphicsCommandList` | ëª…ë ¹ì„ ì‘ì„±             | "í•´ì•¼ í•  ì‘ì—… ë¦¬ìŠ¤íŠ¸" ì‘ì„±              |
| `ID3D12CommandAllocator`    | ëª…ë ¹ì„ ì €ì¥í•  ê³µê°„ ì œê³µ | "ì‘ì—… ë¦¬ìŠ¤íŠ¸ë¥¼ ë„£ì„ ë…¸íŠ¸"               |
| `ID3D12CommandQueue`        | GPUì— ì „ë‹¬í•˜ì—¬ ì‹¤í–‰     | "ì‘ì—… ë¦¬ìŠ¤íŠ¸ë¥¼ ì™¸ì£¼ ì—…ì²´(GPU)ì—ê²Œ ì „ë‹¬" |


ì»¤ë§¨ë” íê°€ ì™¸ì£¼ì—ê²Œ ì¼ê°ì„ ì£¼ê¸° ìœ„í•œ ëª…ë ¹íì´ë‹¤.   
ê¹Œë‹¤ë¡œìš´ ì ì€, GPUì—ê²Œ ë¬´ì–¸ê°€ë¥¼ í•´ë¼ í•˜ë©´, ë°”ë¡œ í•¨.   
í•˜ì§€ë§Œ ì§€ê¸ˆì€ ë’¤ëŠ¦ê²Œ ì‘ì—…í•˜ê¸° ë•Œë¬¸ì—, ë°”ë¡œ ì‘ì—…ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤.   

ë°©ì‹ì€ íš¨ìœ¨ì ì´ì§€ë§Œ, ê¸°ì¡´ ë°©ì‹ê³¼ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— **ì ì‘ì´ ì–´ë µë‹¤**.   
ì´ëŸ° ì €ëŸ° ìš”ì²­ ì¤‘ì— swapchain, descritorë“±ì„ ë‹¤ ë“¤ê³  ìˆìŒ.   

- **Command Queue**ëŠ” **GPUì—ê²Œ ì¼ê°ì„ ì£¼ê¸° ìœ„í•œ ëª…ë ¹ í** ì—­í• ì„ í•œë‹¤.
- ê¸°ì¡´ì—ëŠ” **GPUê°€ ì¦‰ì‹œ ëª…ë ¹ì„ ì‹¤í–‰**í–ˆì§€ë§Œ, DX12ì—ì„œëŠ” **Queueì— ì €ì¥ í›„ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰**í•œë‹¤.
- ì´ëŸ¬í•œ ë°©ì‹ì€ íš¨ìœ¨ì ì´ì§€ë§Œ, ê¸°ì¡´ ë°©ì‹ê³¼ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— **ì ì‘ì´ ì–´ë µë‹¤**.
- **SwapChain, Descriptor ë“± ë‹¤ì–‘í•œ ìš”ì²­ì„ í•¨ê»˜ ê´€ë¦¬**í•´ì•¼ í•œë‹¤.
- ì‰½ê²Œ ë§í•´, **GPUì—ê²Œ ì¤„ ì™¸ì£¼ ì¼ê° ëª©ë¡**ì´ë©°, ì´ë¦„ ê·¸ëŒ€ë¡œ **ëª…ë ¹ì„ í(Queue) í˜•íƒœë¡œ ê´€ë¦¬**í•˜ëŠ” êµ¬ì¡°ì´ë‹¤.


##### CommandQueue.cpp - Init
```c++
void CommandQueue::Init(ComPtr<ID3D12Device> device, shared_ptr<SwapChain> swapChain, shared_ptr<DescriptorHeap> descHeap)
{
	_swapChain = swapChain;
	_descHeap = descHeap;

	D3D12_COMMAND_QUEUE_DESC queueDesc = {};
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;

	device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&_cmdQueue)); 

	device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&_cmdAlloc));

	device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, _cmdAlloc.Get(), nullptr, IID_PPV_ARGS(&_cmdList));

	_cmdList->Close();

	device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&_fence));
	_fenceEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);
}
```

##### CommandQueue.cpp - RenderBegin, RenderEnd
```c++
void CommandQueue::RenderBegin(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect)
{
	_cmdAlloc->Reset();
	_cmdList->Reset(_cmdAlloc.Get(), nullptr);

	D3D12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
		_swapChain->GetCurrentBackBufferResource().Get(),
		D3D12_RESOURCE_STATE_PRESENT, // í™”ë©´ ì¶œë ¥
		D3D12_RESOURCE_STATE_RENDER_TARGET); // ì™¸ì£¼ ê²°ê³¼ë¬¼

	_cmdList->ResourceBarrier(1, &barrier);

	// Set the viewport and scissor rect.  This needs to be reset whenever the command list is reset.
	_cmdList->RSSetViewports(1, vp);
	_cmdList->RSSetScissorRects(1, rect);

	// Specify the buffers we are going to render to.
	D3D12_CPU_DESCRIPTOR_HANDLE backBufferView = _descHeap->GetBackBufferView();
	_cmdList->ClearRenderTargetView(backBufferView, Colors::LightSteelBlue, 0, nullptr);
	_cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, nullptr);
}
```
- **Command Allocator & Command List ì´ˆê¸°í™”**
    - `_cmdAlloc->Reset();` â†’ ê¸°ì¡´ ëª…ë ¹ ì´ˆê¸°í™”.
    - `_cmdList->Reset(_cmdAlloc.Get(), nullptr);` â†’ ìƒˆë¡œìš´ ëª…ë ¹ì„ ë°›ì„ ì¤€ë¹„.

- **ë°± ë²„í¼(Back Buffer) ìƒíƒœ ë³€ê²½**
    - `D3D12_RESOURCE_BARRIER`ë¥¼ ì‚¬ìš©í•˜ì—¬ **PRESENT â†’ RENDER_TARGET** ìƒíƒœë¡œ ë³€ê²½.

- **ë·°í¬íŠ¸(Viewport) & ì‹œì €(Rect) ì„¤ì •**
    - `_cmdList->RSSetViewports(1, vp);` â†’ í™”ë©´ í¬ê¸° ì§€ì •.
    - `_cmdList->RSSetScissorRects(1, rect);` â†’ ê·¸ë¦´ ì˜ì—­ ì§€ì •.

- **ë Œë” íƒ€ê²Ÿ ì„¤ì • & ì´ˆê¸°í™”**
    - `_descHeap->GetBackBufferView();` â†’ ë°± ë²„í¼ í•¸ë“¤ ê°€ì ¸ì˜¤ê¸°.
    - `_cmdList->ClearRenderTargetView(..., Colors::LightSteelBlue, ...);` â†’ í™”ë©´ ì´ˆê¸°í™” (ë°°ê²½ìƒ‰: LightSteelBlue).
    - `_cmdList->OMSetRenderTargets(1, &backBufferView, FALSE, nullptr);` â†’ ëœë” íƒ€ê²Ÿ ì„¤ì •.

##### CommandQueue.cpp - RenderEnd
```c++
void CommandQueue::RenderEnd(const D3D12_VIEWPORT* vp, const D3D12_RECT* rect)
{
	D3D12_RESOURCE_BARRIER barrier = CD3DX12_RESOURCE_BARRIER::Transition(
		_swapChain->GetCurrentBackBufferResource().Get(),
		D3D12_RESOURCE_STATE_RENDER_TARGET, // ì™¸ì£¼ ê²°ê³¼ë¬¼
		D3D12_RESOURCE_STATE_PRESENT); // í™”ë©´ ì¶œë ¥

	_cmdList->ResourceBarrier(1, &barrier);
	_cmdList->Close();

	ID3D12CommandList* cmdListArr[] = { _cmdList.Get() };
	_cmdQueue->ExecuteCommandLists(_countof(cmdListArr), cmdListArr); 

	_swapChain->Present();

	// Wait until frame commands are complete.  This waiting is inefficient and is
	// done for simplicity.  Later we will show how to organize our rendering code
	// so we do not have to wait per frame.
	WaitSync();

	_swapChain->SwapIndex();
}
```

- **ë°± ë²„í¼ ìƒíƒœ ë³€ê²½ (Render â†’ Present)**
    - `D3D12_RESOURCE_BARRIER`ë¥¼ ì‚¬ìš©í•˜ì—¬  
        **D3D12_RESOURCE_STATE_RENDER_TARGET â†’ D3D12_RESOURCE_STATE_PRESENT**  
        (ë Œë”ë§ ì™„ë£Œëœ í”„ë ˆì„ì„ í™”ë©´ì— ì¶œë ¥í•  ìˆ˜ ìˆë„ë¡ ë³€ê²½).
- **Command List ì‹¤í–‰**
    - `_cmdList->Close();` â†’ ëª…ë ¹ ë¦¬ìŠ¤íŠ¸ ì‘ì„± ì™„ë£Œ.
    - `_cmdQueue->ExecuteCommandLists(...);` â†’ GPUê°€ ëª…ë ¹ì„ ì‹¤í–‰í•˜ë„ë¡ ì „ë‹¬.
- **í”„ë ˆì„ ì¶œë ¥ & ë™ê¸°í™”**
    - `_swapChain->Present();` â†’ í˜„ì¬ í”„ë ˆì„ì„ í™”ë©´ì— ì¶œë ¥.
    - `WaitSync();` â†’ GPU & CPU ë™ê¸°í™” (ë¹„íš¨ìœ¨ì ì´ì§€ë§Œ ê¸°ë³¸ì ì¸ êµ¬í˜„).
- **SwapChain ì¸ë±ìŠ¤ ë³€ê²½**
    - `_swapChain->SwapIndex();` â†’ ë‹¤ìŒ í”„ë ˆì„ì„ ìœ„í•œ ë°± ë²„í¼ ì¸ë±ìŠ¤ ë³€ê²½.

##### CommandQueue.cpp - WaitSync
```c++
#include "pch.h"
#include "CommandQueue.h"
#include "SwapChain.h"
#include "DescriptorHeap.h"

CommandQueue::~CommandQueue()
{
	::CloseHandle(_fenceEvent);
	// ë™ì  í• ë‹¹í–ˆì„ ë•Œ deleteë¥¼ í•´ì£¼ëŠ” ê²Œ ì •ì„ì¸ ê²ƒì²˜ëŸ¼
	// ì´ë²¤íŠ¸ë¥¼ ì‚¬ìš©í•  ë’¤ì—ëŠ” CloseHandleì„ í•´ì£¼ëŠ” ê²ƒì´ ì •ì„
}

void CommandQueue::Init(ComPtr<ID3D12Device> device, shared_ptr<SwapChain> swapChain, shared_ptr<DescriptorHeap> descHeap)
{
	...

	device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&_fence));
	_fenceEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);

}

void CommandQueue::WaitSync()
{
	// cpuê°€ gpuë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒ
	// fenceì˜ ì¼ê°ì´ ëª¨ë‘ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒ
	// Advance the fence value to mark commands up to this fence point.
	_fenceValue++;

	// Add an instruction to the command queue to set a new fence point.  Because we 
	// are on the GPU timeline, the new fence point won't be set until the GPU finishes
	// processing all the commands prior to this Signal().
	_cmdQueue->Signal(_fence.Get(), _fenceValue);

	// Wait until the GPU has completed commands up to this fence point.
	if (_fence->GetCompletedValue() < _fenceValue)
	{
		// Fire event when GPU hits current fence.  
		_fence->SetEventOnCompletion(_fenceValue, _fenceEvent);

		// Wait until the GPU hits current fence event is fired.
		::WaitForSingleObject(_fenceEvent, INFINITE);
	}
}
```

- **Fence(íœìŠ¤)ë€?**
    - GPUì™€ CPUì˜ ì‘ì—… íƒ€ì´ë°ì„ ë§ì¶”ê¸° ìœ„í•œ **ë™ê¸°í™” ë„êµ¬**.
    - GPUê°€ **ëª¨ë“  ëª…ë ¹ì„ ì™„ë£Œí•  ë•Œê¹Œì§€** CPUê°€ ëŒ€ê¸°í•˜ë„ë¡ ë§Œë“¦.
- **WaitSync() ë™ì‘ ê³¼ì •**
    - `_fenceValue++` â†’ ìƒˆë¡œìš´ íœìŠ¤ ê°’ì„ ì„¤ì •.
    - `_cmdQueue->Signal(_fence.Get(), _fenceValue);`  
        â†’ GPUê°€ ì´ íœìŠ¤ ê°’ê¹Œì§€ ëª¨ë“  ëª…ë ¹ì„ ì™„ë£Œí•˜ë©´ ì‹ í˜¸ë¥¼ ë³´ëƒ„.
    - `_fence->SetEventOnCompletion(_fenceValue, _fenceEvent);`  
        â†’ GPUê°€ í•´ë‹¹ íœìŠ¤ ê°’ì„ ì™„ë£Œí•˜ë©´ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚´.
    - `WaitForSingleObject(_fenceEvent, INFINITE);`  
        â†’ **GPUê°€ ì‘ì—…ì„ ì™„ë£Œí•  ë•Œê¹Œì§€ CPUê°€ ëŒ€ê¸°**.
- ì •ë¦¬   
  - GPUê°€ ëë‚˜ì•¼ CPUê°€ ìƒˆë¡œìš´ ì‘ì—…ì„ ì „ë‹¬í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— **íœìŠ¤ë¥¼ ì‚¬ìš©í•´ ë™ê¸°í™”**.
  - `WaitSync()`ëŠ” **CPUê°€ GPUì˜ ì‘ì—… ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì—­í• **ì„ ìˆ˜í–‰.
  - `CloseHandle(_fenceEvent);` â†’ ë™ì  í• ë‹¹í•œ ì´ë²¤íŠ¸ í•¸ë“¤ì€ í•´ì œí•´ì•¼ í•¨ (ë©”ëª¨ë¦¬ ê´€ë¦¬).
- ê²°ë¡    
GPUì™€ CPUì˜ ì‘ì—… ì†ë„ê°€ ë‹¤ë¥´ë¯€ë¡œ, **Fenceë¥¼ ì‚¬ìš©í•´ ë™ê¸°í™”ë¥¼ ë§ì¶”ê³  CPUê°€ GPUì˜ ì‘ì—… ì™„ë£Œë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ë°©ì‹**ìœ¼ë¡œ ë™ì‘í•œë‹¤.